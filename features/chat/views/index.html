{{ define "index" }}
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <title>Shell>> chat</title>
      {{block "meta" .}}{{end}}
      <style>
       .option {
           padding: 1rem 2rem;
           color: #2f3236;
       }
      </style>
    </head>
    <body class="flex flex-col flex-grow h-screen">
      <header class="flex justify-between items-center bg-gray-200">
	{{if .Chat.Title}}
	  <h1>{{.Chat.Title}}</h1>
	  <div hx-get="{{.Chat.ID}}/tags" hx-swap="outerHTML" hx-trigger="load"></div>
	{{else}}
	  <h1>New chat</h1>
	{{end}}
	{{if .Chat.Messages}}
	  <a href="/chat" class="bg-blue-300 p-2">Start a new chat</a>
	{{end}}
      </header>
      {{template "messages" .Chat}}
      <form
	hx-post="{{ .Chat.ID }}/message"
	hx-target="#messages"
	hx-on::after-request="if(event.detail.successful) this.reset()"
	class="flex items-center justify-center bg-gray-400 p-4"
      >
	<div class="relative">
	    <textarea class="h-30 w-96 bg-white p-2"  id="prompt" name="prompt" type="text" required placeholder="Prompt..."></textarea>
            <div id='autocomplete' class="absolute z-10 bg-blue-100 border border-blue-500 rounded py-2 w-64 max-h-60 overflow-y-auto hidden"></div>
	  <button type="submit">Send</button>
	</div>
      </form>
    </body>
    <script>
     const textarea = document.getElementById("prompt")
     const autocompletePopup = document.getElementById("autocomplete")
     const autocompleteOptions = {{.ChatTitles}}

     let filteredOptions = [];
     let selectedIndex = -1;

     function positionPopup() {
       const textareaRect = textarea.getBoundingClientRect();

       autocompletePopup.style.bottom = "100%";
       autocompletePopup.style.left = "0";
       autocompletePopup.style.width = `${textareaRect.width}px`;
     }

     function renderOptions() {
       autocompletePopup.innerHTML = '';

       if (filteredOptions.length === 0) {
         autocompletePopup.innerHTML = '';
         return;
       }

       filteredOptions.forEach((option, index) => {
         const optionDiv = document.createElement('div');
         optionDiv.className = `option text-base rounded-lg
                                 ${index === selectedIndex ? 'bg-blue-100 text-blue-700 font-semibold' : 'hover:bg-gray-100'}`;
         optionDiv.textContent = option.Title;
         optionDiv.dataset.option = option.Title;

         optionDiv.addEventListener('click', () => insertOption(option));
         autocompletePopup.appendChild(optionDiv);
       });

       if (selectedIndex !== -1) {
         const selectedElement = autocompletePopup.children[selectedIndex];
         if (selectedElement) {
           selectedElement.scrollIntoView({ block: 'nearest', inline: 'nearest' });
         }
       }
     }

     function insertOption(option) {
       const cursorPosition = textarea.selectionStart;
       const currentText = textarea.value;
       const atIndex = currentText.lastIndexOf('@', cursorPosition - 1);

       if (atIndex !== -1) {
         const textBeforeAt = currentText.substring(0, atIndex);
         const textAfterCursor = currentText.substring(cursorPosition);

         const newText = `${textBeforeAt}@${option.Title} ${textAfterCursor}`;
         textarea.value = newText;

         const newCursorPosition = atIndex + 1 + option.Title.length + 1;
         textarea.setSelectionRange(newCursorPosition, newCursorPosition);

         hideAutocomplete();
         textarea.focus();
       }
     }

     function showAutocomplete() {
       autocompletePopup.classList.remove('hidden');
       positionPopup();
       renderOptions();
     }

     function hideAutocomplete() {
       autocompletePopup.classList.add('hidden');
       selectedIndex = -1;
       filteredOptions = [];
     }

     textarea.addEventListener('input', (e) => {
       const newText = e.target.value;
       const cursorPosition = e.target.selectionStart;
       const atIndex = newText.lastIndexOf('@', cursorPosition - 1);

       let shouldShow = false;
       let searchString = '';

       const noSymbolBefore = newText[atIndex - 1] == " " || cursorPosition === 1
       const atBeforeTheCursor = cursorPosition === atIndex + 1
       const atFollwedByNonSpace = newText[cursorPosition - 1] !== ' ' && cursorPosition > atIndex

       // Check if '@' is present and immediately before the cursor or followed by non-space chars
       if (atIndex !== -1 && noSymbolBefore && ( atBeforeTheCursor || (atFollowedByNonSpace))) {
         searchString = newText.substring(atIndex + 1, cursorPosition);
         // Filter options based on search string
         const filtered = autocompleteOptions.filter(option =>
           option.Title.toLowerCase().startsWith(searchString.toLowerCase())
         );
         filteredOptions = filtered;
         shouldShow = filtered.length > 0;
       }

       if (shouldShow) {
         selectedIndex = -1; // Reset selection on new input
         showAutocomplete();
       } else {
         hideAutocomplete();
       }
     });

     textarea.addEventListener('keydown', (e) => {
       if (autocompletePopup.classList.contains('hidden')) {
         return; // Only handle if popup is visible
       }

       if (e.key === 'ArrowDown') {
         e.preventDefault(); // Prevent cursor movement in textarea
         selectedIndex = (selectedIndex + 1) % filteredOptions.length;
         renderOptions();
       } else if (e.key === 'ArrowUp') {
         e.preventDefault(); // Prevent cursor movement in textarea
         selectedIndex = (selectedIndex - 1 + filteredOptions.length) % filteredOptions.length;
         renderOptions();
       } else if (e.key === 'Enter') {
         e.preventDefault(); // Prevent new line in textarea
         if (selectedIndex !== -1) {
           insertOption(filteredOptions[selectedIndex]);
         }
       } else if (e.key === 'Escape') {
         hideAutocomplete();
       }
     });

     // Hide popup if clicking outside textarea or popup
     document.addEventListener('click', (e) => {
       if (!textarea.contains(e.target) && !autocompletePopup.contains(e.target)) {
         hideAutocomplete();
       }
     });

     // Re-position popup on window resize
     window.addEventListener('resize', positionPopup);

    </script>
  </html>
{{ end }}
